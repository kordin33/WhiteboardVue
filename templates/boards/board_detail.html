{% extends 'base.html' %}

{% block title %}{{ board.title }}{% endblock %}

{% block extra_css %}
.whiteboard-container {
    position: relative;
    width: 100%;
    height: calc(100vh - 120px);
    background-color: #f0f0f0;
    border: 1px solid #ddd;
    overflow: hidden;
}
#whiteboard-canvas {
    position: absolute;
    top: 0;
    left: 0;
    cursor: move;
    background-color: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
.tools-panel {
    position: fixed;
    top: 70px;
    left: 10px;
    z-index: 1000;
    background-color: white;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    padding: 10px;
}
.tools-panel .btn {
    margin: 3px;
    width: 36px;
    height: 36px;
    padding: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.element-properties {
    position: fixed;
    top: 70px;
    right: 10px;
    width: 250px;
    z-index: 1000;
    background-color: white;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    padding: 15px;
    display: none;
}
.read-only-indicator {
    position: fixed;
    top: 70px;
    right: 10px;
    background-color: rgba(255, 0, 0, 0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 3px;
    font-weight: bold;
}
.pen-properties {
    display: none;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
}
.grid-settings {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
}
.active-tool {
    background-color: #0d6efd !important;
    color: white !important;
}
.brush-size-btn {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: inline-block;
    margin: 0 2px;
    cursor: pointer;
    border: 1px solid #ccc;
}
.brush-size-btn.active {
    border: 2px solid #0d6efd;
}
{% endblock %}

{% block content %}
<div class="col-12 p-0">
    <div class="d-flex justify-content-between align-items-center p-2 bg-light border-bottom">
        <h3 class="mb-0">{{ board.title }}</h3>
        <div>
            <button id="save-board" class="btn btn-success btn-sm">Zapisz</button>
            <a href="{% url 'board_list' %}" class="btn btn-outline-secondary btn-sm">Powrót</a>
        </div>
    </div>

    {% if not can_edit %}
    <div class="read-only-indicator">
        Tylko podgląd
    </div>
    {% endif %}

    {% if can_edit %}
    <div class="tools-panel">
        <div class="btn-group-vertical">
            <button class="btn btn-outline-secondary tool-btn" data-tool="select" title="Wybierz element">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor" viewBox="0 0 16 16">
                    <path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="pen" title="Rysuj odręcznie">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pen" viewBox="0 0 16 16">
                    <path d="m13.498.795.149-.149a1.207 1.207 0 1 1 1.707 1.708l-.149.148a1.5 1.5 0 0 1-.059 2.059L4.854 14.854a.5.5 0 0 1-.233.131l-4 1a.5.5 0 0 1-.606-.606l1-4a.5.5 0 0 1 .131-.232l9.642-9.642a.5.5 0 0 0-.642.056L6.854 4.854a.5.5 0 1 1-.708-.708L9.44.854A1.5 1.5 0 0 1 11.5.796a1.5 1.5 0 0 1 1.998-.001z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="text" title="Dodaj tekst">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-fonts" viewBox="0 0 16 16">
                    <path d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="sticky" title="Dodaj notatkę">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-sticky" viewBox="0 0 16 16">
                    <path d="M2.5 1A1.5 1.5 0 0 0 1 2.5v11A1.5 1.5 0 0 0 2.5 15h6.086a1.5 1.5 0 0 0 1.06-.44l4.915-4.914A1.5 1.5 0 0 0 15 8.586V2.5A1.5 1.5 0 0 0 13.5 1h-11zM2 2.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 .5.5V8H9.5A1.5 1.5 0 0 0 8 9.5V14H2.5a.5.5 0 0 1-.5-.5v-11zm7 11.293V9.5a.5.5 0 0 1 .5-.5h4.293L9 13.793z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="shape" title="Dodaj kształt">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-square" viewBox="0 0 16 16">
                    <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="line" title="Dodaj linię">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-slash-lg" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M13.854 2.146a.5.5 0 0 1 0 .708l-11 11a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708 0Z"/>
                </svg>
            </button>
            <button class="btn btn-outline-secondary tool-btn" data-tool="image" title="Dodaj obraz">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image" viewBox="0 0 16 16">
                    <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                    <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
                </svg>
            </button>
        </div>

        <!-- Właściwości ołówka/pióra -->
        <div class="pen-properties" id="pen-properties">
            <p class="mb-1 text-center">Rozmiar pióra:</p>
            <div class="d-flex justify-content-center">
                <div class="brush-size-btn" data-size="2" style="background-color: #000"></div>
                <div class="brush-size-btn" data-size="5" style="background-color: #000"></div>
                <div class="brush-size-btn active" data-size="10" style="background-color: #000"></div>
                <div class="brush-size-btn" data-size="15" style="background-color: #000"></div>
            </div>
            <p class="mb-1 mt-2 text-center">Kolor:</p>
            <div class="d-flex justify-content-center">
                <input type="color" id="pen-color" value="#000000" class="form-control form-control-sm" style="width: 100px;">
            </div>
            <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="pen-smoothing" checked>
                <label class="form-check-label" for="pen-smoothing">
                    Wygładzanie linii
                </label>
            </div>
        </div>

        <!-- Ustawienia siatki -->
        <div class="grid-settings">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="show-grid" checked>
                <label class="form-check-label" for="show-grid">
                    Pokaż siatkę
                </label>
            </div>
            <div class="mt-2">
                <label for="grid-size" class="form-label">Rozmiar siatki:</label>
                <select id="grid-size" class="form-select form-select-sm">
                    <option value="10">Mała (10px)</option>
                    <option value="20" selected>Średnia (20px)</option>
                    <option value="40">Duża (40px)</option>
                </select>
            </div>
        </div>
    </div>

    <div class="element-properties" id="properties-panel">
        <h5>Właściwości elementu</h5>
        <div id="common-props">
            <div class="mb-2">
                <label for="element-z-index" class="form-label">Warstwa (Z-Index)</label>
                <input type="number" class="form-control form-control-sm" id="element-z-index">
            </div>
            <button id="delete-element" class="btn btn-danger btn-sm mt-2">Usuń element</button>
        </div>

        <div id="text-props" style="display: none;">
            <div class="mb-2">
                <label for="text-content" class="form-label">Tekst</label>
                <textarea class="form-control form-control-sm" id="text-content" rows="3"></textarea>
            </div>
            <div class="mb-2">
                <label for="text-color" class="form-label">Kolor</label>
                <input type="color" class="form-control form-control-sm" id="text-color">
            </div>
            <div class="mb-2">
                <label for="text-size" class="form-label">Rozmiar</label>
                <select class="form-select form-select-sm" id="text-size">
                    <option value="12px">Mały (12px)</option>
                    <option value="16px" selected>Średni (16px)</option>
                    <option value="24px">Duży (24px)</option>
                    <option value="32px">Bardzo duży (32px)</option>
                </select>
            </div>
        </div>

        <div id="shape-props" style="display: none;">
            <div class="mb-2">
                <label for="shape-type" class="form-label">Kształt</label>
                <select class="form-select form-select-sm" id="shape-type">
                    <option value="rectangle">Prostokąt</option>
                    <option value="circle">Koło</option>
                    <option value="triangle">Trójkąt</option>
                </select>
            </div>
            <div class="mb-2">
                <label for="shape-color" class="form-label">Kolor wypełnienia</label>
                <input type="color" class="form-control form-control-sm" id="shape-color">
            </div>
            <div class="mb-2">
                <label for="shape-border-color" class="form-label">Kolor obramowania</label>
                <input type="color" class="form-control form-control-sm" id="shape-border-color">
            </div>
        </div>
    </div>
    {% endif %}

    <div class="whiteboard-container">
        <canvas id="whiteboard-canvas" width="3000" height="2000"></canvas>
    </div>

    <!-- WebSocket Test Panel -->
    <div id="ws-test-panel" style="position: fixed; bottom: 10px; right: 10px; background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; z-index: 1000; display: none;">
        <h5>Test WebSocket</h5>
        <p>Status: <span id="ws-status">Niepołączony</span></p>
        <button id="ws-test-btn" class="btn btn-sm btn-primary">Test połączenia</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="/static/js/websocket_test.js"></script>
<script>
    // Inicjalizacja danych
    const boardId = {{ board.id }};
    const canEdit = {% if can_edit %}true{% else %}false{% endif %};
    let canvas;
    let currentTool = 'select';
    let socket;
    let isDrawing = false;
    let startPoint;
    let tempShape;
    let penSize = 10;
    let penColor = '#000000';
    let penSmoothing = true;
    let gridSize = 20;
    let showGrid = true;
    let gridLines = [];

    // Inicjalizacja WebSocket połączenia
    function initializeWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/boards/${boardId}/`;
        console.log('Łączenie z WebSocket URL:', wsUrl);

        try {
            socket = new WebSocket(wsUrl);

            socket.onopen = function(e) {
                console.log('WebSocket połączony pomyślnie');
                const statusElement = document.getElementById('ws-status');
                if (statusElement) {
                    statusElement.textContent = 'Połączony';
                    statusElement.style.color = 'green';
                }
            };

            socket.onmessage = function(e) {
                try {
                    const data = JSON.parse(e.data);
                    console.log('Otrzymano wiadomość WebSocket:', data);

                    // Obsługa przychodzących zdarzeń
                    if (data.action === 'create_element') {
                        addElementFromData(data.element);
                    } else if (data.action === 'update_element') {
                        updateElementFromData(data.element);
                    } else if (data.action === 'delete_element') {
                        deleteElementById(data.element_id);
                    }
                } catch (error) {
                    console.error('Błąd przetwarzania wiadomości WebSocket:', error);
                }
            };

            socket.onclose = function(e) {
                console.log('WebSocket rozłączony, kod:', e.code, 'powód:', e.reason);
                const statusElement = document.getElementById('ws-status');
                if (statusElement) {
                    statusElement.textContent = 'Rozłączony (kod: ' + e.code + ')';
                    statusElement.style.color = 'red';
                }

                // Próba ponownego połączenia po 5 sekundach
                setTimeout(initializeWebSocket, 5000);
            };

            socket.onerror = function(e) {
                console.error('Błąd WebSocket:', e);
                const statusElement = document.getElementById('ws-status');
                if (statusElement) {
                    statusElement.textContent = 'Błąd połączenia';
                    statusElement.style.color = 'red';
                }
            };
        } catch (error) {
            console.error('Błąd tworzenia WebSocket:', error);
        }
    }

    // Inicjalizacja Canvas
    function initCanvas() {
        try {
            // Utworzenie canvas z odpowiednią konfiguracją
            canvas = new fabric.Canvas('whiteboard-canvas', {
                isDrawingMode: false,
                selection: canEdit,
                backgroundColor: 'white'
            });

            console.log('Canvas zainicjalizowany pomyślnie');

            // Tworzenie siatki
            createGrid();

            // Konfiguracja narzędzia do rysowania odręcznego
            configureFreeDrawing();

            // Konfiguracja obsługi zdarzeń canvas
            setupCanvasEventListeners();

            // Ładowanie elementów z serwera
            loadBoardElements();
        } catch (error) {
            console.error('Błąd inicjalizacji canvas:', error);
        }
    }

    // Tworzenie siatki
    function createGrid() {
        // Usuń istniejące linie siatki
        gridLines.forEach(line => {
            canvas.remove(line);
        });
        gridLines = [];

        if (!showGrid) return;

        const width = canvas.width;
        const height = canvas.height;

        // Tworzenie linii pionowych
        for (let i = 0; i < width; i += gridSize) {
            const line = new fabric.Line([i, 0, i, height], {
                stroke: '#ddd',
                selectable: false,
                strokeWidth: i % (gridSize * 5) === 0 ? 1 : 0.5,
                element_type: 'grid'
            });
            gridLines.push(line);
            canvas.add(line);
        }

        // Tworzenie linii poziomych
        for (let i = 0; i < height; i += gridSize) {
            const line = new fabric.Line([0, i, width, i], {
                stroke: '#ddd',
                selectable: false,
                strokeWidth: i % (gridSize * 5) === 0 ? 1 : 0.5,
                element_type: 'grid'
            });
            gridLines.push(line);
            canvas.add(line);
        }

        // Przesuń siatkę na spód
        gridLines.forEach(line => {
            line.moveTo(0);
        });

        canvas.renderAll();
    }

    // Konfiguracja rysowania odręcznego
    function configureFreeDrawing() {
        const brush = canvas.freeDrawingBrush;
        brush.color = penColor;
        brush.width = penSize;

        // Włączenie wygładzania linii jeśli wybrane
        if (penSmoothing) {
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.color = penColor;
            canvas.freeDrawingBrush.width = penSize;
            canvas.freeDrawingBrush.strokeLineCap = 'round';
            canvas.freeDrawingBrush.strokeLineJoin = 'round';
        }
    }

    // Konfiguracja obsługi zdarzeń canvas
    function setupCanvasEventListeners() {
        // Obsługa zoom
        canvas.on('mouse:wheel', function(opt) {
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.1) zoom = 0.1;

            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        // Obsługa przesuwania płótna
        canvas.on('mouse:down', function(opt) {
            if (currentTool === 'select' && opt.e.altKey) {
                this.isDragging = true;
                this.selection = false;
                this.lastPosX = opt.e.clientX;
                this.lastPosY = opt.e.clientY;
            }

            // Obsługa rysowania kształtów przez przeciąganie
            if (['shape', 'line'].includes(currentTool) && !opt.target && !this.isDragging) {
                isDrawing = true;
                startPoint = canvas.getPointer(opt.e);

                if (currentTool === 'shape') {
                    // Tworzenie tymczasowego kształtu
                    const shapeType = document.getElementById('shape-type') ? document.getElementById('shape-type').value : 'rectangle';
                    const fill = document.getElementById('shape-color') ? document.getElementById('shape-color').value : '#3498db';
                    const stroke = document.getElementById('shape-border-color') ? document.getElementById('shape-border-color').value : '#2980b9';

                    if (shapeType === 'circle') {
                        tempShape = new fabric.Circle({
                            left: startPoint.x,
                            top: startPoint.y,
                            radius: 1,
                            fill: fill,
                            stroke: stroke,
                            strokeWidth: 2,
                            selectable: false,
                            originX: 'center',
                            originY: 'center'
                        });
                    } else if (shapeType === 'triangle') {
                        tempShape = new fabric.Triangle({
                            left: startPoint.x,
                            top: startPoint.y,
                            width: 1,
                            height: 1,
                            fill: fill,
                            stroke: stroke,
                            strokeWidth: 2,
                            selectable: false
                        });
                    } else {
                        tempShape = new fabric.Rect({
                            left: startPoint.x,
                            top: startPoint.y,
                            width: 1,
                            height: 1,
                            fill: fill,
                            stroke: stroke,
                            strokeWidth: 2,
                            rx: 5,
                            ry: 5,
                            selectable: false
                        });
                    }
                    canvas.add(tempShape);
                }
                else if (currentTool === 'line') {
                    // Tworzenie tymczasowej linii
                    const stroke = document.getElementById('pen-color') ? document.getElementById('pen-color').value : '#000000';
                    tempShape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
                        stroke: stroke,
                        strokeWidth: 2,
                        selectable: false
                    });
                    canvas.add(tempShape);
                }
            }
        });

        canvas.on('mouse:move', function(opt) {
            // Obsługa przeciągania płótna
            if (this.isDragging) {
                const e = opt.e;
                const vpt = this.viewportTransform;
                vpt[4] += e.clientX - this.lastPosX;
                vpt[5] += e.clientY - this.lastPosY;
                this.requestRenderAll();
                this.lastPosX = e.clientX;
                this.lastPosY = e.clientY;
            }

            // Obsługa dynamicznego rysowania kształtu
            if (isDrawing && tempShape) {
                const pointer = canvas.getPointer(opt.e);

                if (tempShape.type === 'circle') {
                    // Obliczanie promienia koła
                    const radius = Math.sqrt(
                        Math.pow(pointer.x - startPoint.x, 2) + 
                        Math.pow(pointer.y - startPoint.y, 2)
                    ) / 2;

                    const centerX = (startPoint.x + pointer.x) / 2;
                    const centerY = (startPoint.y + pointer.y) / 2;

                    tempShape.set({
                        radius: radius,
                        left: centerX,
                        top: centerY
                    });
                }
                else if (tempShape.type === 'triangle' || tempShape.type === 'rect') {
                    // Ustawianie wymiarów prostokąta lub trójkąta
                    const width = Math.abs(pointer.x - startPoint.x);
                    const height = Math.abs(pointer.y - startPoint.y);
                    const left = pointer.x < startPoint.x ? pointer.x : startPoint.x;
                    const top = pointer.y < startPoint.y ? pointer.y : startPoint.y;

                    tempShape.set({
                        left: left,
                        top: top,
                        width: width,
                        height: height
                    });
                }
                else if (tempShape.type === 'line') {
                    // Aktualizacja końca linii
                    tempShape.set({
                        x2: pointer.x,
                        y2: pointer.y
                    });
                }

                canvas.renderAll();
            }
        });

        canvas.on('mouse:up', function(opt) {
            // Zakończenie przeciągania płótna
            this.isDragging = false;
            this.selection = canEdit;

            // Zakończenie rysowania kształtu
            if (isDrawing && tempShape) {
                isDrawing = false;
                const pointer = canvas.getPointer(opt.e);

                // Sprawdzenie czy kształt ma minimalny rozmiar
                const minSize = 5;
                const width = Math.abs(pointer.x - startPoint.x);
                const height = Math.abs(pointer.y - startPoint.y);

                if (width < minSize && height < minSize) {
                    // Kształt za mały, usuń go
                    canvas.remove(tempShape);
                } else {
                    // Kształt odpowiedniej wielkości, dodaj go jako element
                    tempShape.selectable = true;
                    tempShape.element_type = currentTool === 'line' ? 'line' : 'shape';

                    // Dodanie właściwości specyficznych dla kształtów
                    if (tempShape.element_type === 'shape') {
                        const shapeType = tempShape.type === 'circle' ? 'circle' : 
                                          tempShape.type === 'triangle' ? 'triangle' : 'rectangle';
                        tempShape.properties = {
                            type: shapeType,
                            fill: tempShape.fill,
                            stroke: tempShape.stroke
                        };
                    } else if (tempShape.element_type === 'line') {
                        tempShape.properties = {
                            stroke: tempShape.stroke,
                            strokeWidth: tempShape.strokeWidth
                        };
                    }

                    // Wysłanie informacji o utworzeniu elementu
                    sendElementCreate(tempShape);
                }

                tempShape = null;

                // Powrót do narzędzia wyboru po narysowaniu kształtu
                if (['shape', 'line'].includes(currentTool)) {
                    document.querySelector('[data-tool="select"]')?.click();
                }
            }
        });

        // Obsługa zaznaczenia elementów
        canvas.on('selection:created', function(options) {
            if (canEdit && options.selected && options.selected.length > 0) {
                showPropertiesPanel(options.selected[0]);
            }
        });

        canvas.on('selection:updated', function(options) {
            if (canEdit && options.selected && options.selected.length > 0) {
                showPropertiesPanel(options.selected[0]);
            }
        });

        canvas.on('selection:cleared', function() {
            hidePropertiesPanel();
        });

        // Obsługa modyfikacji obiektów
        canvas.on('object:modified', function(options) {
            if (canEdit && options.target) {
                console.log('Obiekt zmodyfikowany:', options.target);
                sendElementUpdate(options.target);
            }
        });

        // Obsługa zakończenia rysowania odręcznego
        canvas.on('path:created', function(e) {
            if (e.path && canEdit) {
                e.path.element_type = 'path';
                e.path.properties = {
                    stroke: e.path.stroke,
                    strokeWidth: e.path.strokeWidth
                };
                sendElementCreate(e.path);
            }
        });
    }

    // Funkcje obsługi WebSocket
    function receiveCreateElement(element) {
        addElementFromData(element);
    }

    function receiveUpdateElement(element) {
        updateElementFromData(element);
    }

    function receiveDeleteElement(elementId) {
        deleteElementById(elementId);
    }

    // Ładowanie elementów tablicy z serwera
    function loadBoardElements() {
        fetch(`/api/${boardId}/elements/`)
            .then(response => response.json())
            .then(elements => {
                elements.forEach(element => {
                    addElementFromData(element);
                });
            })
            .catch(error => console.error('Błąd ładowania elementów tablicy:', error));
    }

    // Dodawanie elementu na podstawie danych
    function addElementFromData(elementData) {
        switch(elementData.element_type) {
            case 'text':
                addTextElement(elementData);
                break;
            case 'sticky':
                addStickyNote(elementData);
                break;
            case 'shape':
                addShapeElement(elementData);
                break;
            case 'line':
                addLineElement(elementData);
                break;
            case 'image':
                addImageElement(elementData);
                break;
            case 'path':
                addPathElement(elementData);
                break;
        }
    }

    // Dodawanie elementu ścieżki (rysowanie odręczne)
    function addPathElement(data) {
        if (!data.path) return null;

        const pathObj = new fabric.Path(data.path, {
            id: data.id,
            left: data.position_x || 0,
            top: data.position_y || 0,
            stroke: data.properties?.stroke || '#000000',
            strokeWidth: data.properties?.strokeWidth || 5,
            fill: null,
            element_type: 'path',
            selectable: canEdit
        });

        canvas.add(pathObj);
        canvas.renderAll();

        return pathObj;
    }

    // Aktualizacja elementu na podstawie danych
    function updateElementFromData(elementData) {
        const objects = canvas.getObjects();
        const element = objects.find(obj => obj.id === elementData.id);

        if (element) {
            // Aktualizacja wspólnych właściwości
            element.set({
                left: elementData.position_x,
                top: elementData.position_y,
                width: elementData.width,
                height: elementData.height,
                angle: elementData.rotation,
                zIndex: elementData.z_index
            });

            // Aktualizacja specyficznych właściwości
            if (elementData.element_type === 'text' && elementData.content) {
                element.set('text', elementData.content);

                if (elementData.properties && elementData.properties.color) {
                    element.set('fill', elementData.properties.color);
                }

                if (elementData.properties && elementData.properties.fontSize) {
                    element.set('fontSize', elementData.properties.fontSize);
                }
            }
            else if (['sticky', 'shape'].includes(elementData.element_type) && elementData.properties) {
                if (elementData.properties.fill) {
                    element.set('fill', elementData.properties.fill);
                }

                if (elementData.properties.stroke) {
                    element.set('stroke', elementData.properties.stroke);
                }

                if (elementData.element_type === 'sticky' && elementData.content) {
                    // Aktualizacja tekstu w notatce
                    const textObjects = element._objects.filter(obj => obj.type === 'text');
                    if (textObjects.length > 0) {
                        textObjects[0].set('text', elementData.content);
                    }
                }
            } else if (elementData.element_type === 'path' && elementData.properties) {
                if (elementData.properties.stroke) {
                    element.set('stroke', elementData.properties.stroke);
                }
                if (elementData.properties.strokeWidth) {
                    element.set('strokeWidth', elementData.properties.strokeWidth);
                }
            }

            canvas.renderAll();
        }
    }

    // Usunięcie elementu po ID
    function deleteElementById(elementId) {
        const objects = canvas.getObjects();
        const element = objects.find(obj => obj.id === elementId);

        if (element) {
            canvas.remove(element);
            canvas.renderAll();
        }
    }

    // Dodawanie tekstu
    function addTextElement(data) {
        const fontSize = data.properties?.fontSize || '16px';
        const color = data.properties?.color || '#000000';

        const textObj = new fabric.Textbox(data.content || 'Nowy tekst', {
            id: data.id,
            left: data.position_x || 100,
            top: data.position_y || 100,
            width: data.width || 200,
            fontSize: fontSize,
            fill: color,
            fontFamily: 'Arial',
            element_type: 'text',
            selectable: canEdit
        });

        canvas.add(textObj);
        canvas.renderAll();

        // Automatyczne otwarcie edycji tekstu po utworzeniu
        if (!data.id && canEdit) {
            textObj.enterEditing();
            textObj.hiddenTextarea.focus();
        }

        // Jeśli to nowy element, wysyłamy informację do serwera
        if (!data.id && canEdit) {
            sendElementCreate(textObj);
        }

        return textObj;
    }

    // Dodawanie notatki
    function addStickyNote(data) {
        const color = data.properties?.fill || '#FFFF88';
        const width = data.width || 200;
        const height = data.height || 200;

        const rect = new fabric.Rect({
            width: width,
            height: height,
            fill: color,
            rx: 10,
            ry: 10
        });

        const text = new fabric.Textbox(data.content || 'Nowa notatka', {
            width: width - 20,
            fontSize: 16,
            fill: '#000000',
            fontFamily: 'Arial',
            left: 10,
            top: 10
        });

        const group = new fabric.Group([rect, text], {
            id: data.id,
            left: data.position_x || 100,
            top: data.position_y || 100,
            element_type: 'sticky',
            selectable: canEdit
        });

        canvas.add(group);
        canvas.renderAll();

        // Jeśli to nowy element, wysyłamy informację do serwera
        if (!data.id && canEdit) {
            sendElementCreate(group);
        }

        return group;
    }

    // Dodawanie kształtu
    function addShapeElement(data) {
        const type = data.properties?.type || 'rectangle';
        const fill = data.properties?.fill || '#3498db';
        const stroke = data.properties?.stroke || '#2980b9';
        let shape;

        if (type === 'circle') {
            shape = new fabric.Circle({
                radius: data.width/2 || 50,
                fill: fill,
                stroke: stroke,
                strokeWidth: 2
            });
        } else if (type === 'triangle') {
            shape = new fabric.Triangle({
                width: data.width || 100,
                height: data.height || 100,
                fill: fill,
                stroke: stroke,
                strokeWidth: 2
            });
        } else {
            // Default: rectangle
            shape = new fabric.Rect({
                width: data.width || 100,
                height: data.height || 100,
                fill: fill,
                stroke: stroke,
                strokeWidth: 2,
                rx: 5,
                ry: 5
            });
        }

        shape.set({
            id: data.id,
            left: data.position_x || 100,
            top: data.position_y || 100,
            element_type: 'shape',
            selectable: canEdit
        });

        canvas.add(shape);
        canvas.renderAll();

        // Jeśli to nowy element, wysyłamy informację do serwera
        if (!data.id && canEdit) {
            sendElementCreate(shape);
        }

        return shape;
    }

    // Dodawanie linii
    function addLineElement(data) {
        const stroke = data.properties?.stroke || '#000000';
        const strokeWidth = data.properties?.strokeWidth || 2;
        const width = data.width || 100;

        const line = new fabric.Line([0, 0, width, 0], {
            id: data.id,
            left: data.position_x || 100,
            top: data.position_y || 100,
            stroke: stroke,
            strokeWidth: strokeWidth,
            element_type: 'line',
            selectable: canEdit
        });

        canvas.add(line);
        canvas.renderAll();

        // Jeśli to nowy element, wysyłamy informację do serwera
        if (!data.id && canEdit) {
            sendElementCreate(line);
        }

        return line;
    }

    // Dodawanie obrazu
    function addImageElement(data) {
        // To jest uproszczona implementacja, w pełnej wersji powinno być wczytywanie z URL
        const imgElement = document.createElement('img');
        imgElement.src = data.image || '/static/placeholder.png';

        imgElement.onload = function() {
            const imgInstance = new fabric.Image(imgElement, {
                id: data.id,
                left: data.position_x || 100,
                top: data.position_y || 100,
                scaleX: (data.width || 200) / imgElement.width,
                scaleY: (data.height || 200) / imgElement.height,
                element_type: 'image',
                selectable: canEdit
            });

            canvas.add(imgInstance);
            canvas.renderAll();

            // Jeśli to nowy element, wysyłamy informację do serwera
            if (!data.id && canEdit) {
                sendElementCreate(imgInstance);
            }
        };
    }

    // Wysyłanie informacji o utworzeniu elementu
    function sendElementCreate(obj) {
        let elementData = {
            element_type: obj.element_type,
            content: obj.text || (obj.type === 'group' ? obj._objects.find(o => o.type === 'textbox')?.text : null),
            position_x: obj.left,
            position_y: obj.top,
            width: obj.width || (obj.radius ? obj.radius * 2 : 100),
            height: obj.height || (obj.radius ? obj.radius * 2 : 100),
            rotation: obj.angle || 0,
            z_index: obj.zIndex || 0,
            properties: {}
        };

        // Dodanie specyficznych właściwości
        if (obj.element_type === 'text') {
            elementData.properties.color = obj.fill;
            elementData.properties.fontSize = obj.fontSize;
        } else if (['shape', 'sticky'].includes(obj.element_type)) {
            elementData.properties.fill = obj.fill || (obj._objects ? obj._objects[0].fill : '#FFFFFF');
            elementData.properties.stroke = obj.stroke || '#000000';
            if (obj.element_type === 'shape') {
                elementData.properties.type = obj.type === 'circle' ? 'circle' : 
                                            obj.type === 'triangle' ? 'triangle' : 'rectangle';
            }
        } else if (obj.element_type === 'line') {
            elementData.properties.stroke = obj.stroke;
            elementData.properties.strokeWidth = obj.strokeWidth;
        } else if (obj.element_type === 'path') {
            // Zapisanie ścieżki do rysowania odręcznego
            elementData.properties.stroke = obj.stroke;
            elementData.properties.strokeWidth = obj.strokeWidth;
            elementData.path = obj.path;
        }

        // Wysłanie do API
        fetch(`/api/${boardId}/elements/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(elementData)
        })
        .then(response => response.json())
        .then(data => {
            // Aktualizacja ID obiektu
            obj.set('id', data.id);

            // Wysłanie do WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'create_element',
                    element: {
                        ...elementData,
                        id: data.id
                    }
                }));
            }
        })
        .catch(error => console.error('Błąd tworzenia elementu:', error));
    }

    // Wysyłanie informacji o aktualizacji elementu
    function sendElementUpdate(obj) {
        const elementData = {
            id: obj.id,
            element_type: obj.element_type,
            position_x: obj.left,
            position_y: obj.top,
            width: obj.width || (obj.radius ? obj.radius * 2 : 100),
            height: obj.height || (obj.radius ? obj.radius * 2 : 100),
            rotation: obj.angle || 0,
            z_index: obj.zIndex || 0,
            properties: {}
        };

        // Dodanie tekstu dla elementów tekstowych
        if (obj.element_type === 'text') {
            elementData.content = obj.text;
            elementData.properties.color = obj.fill;
            elementData.properties.fontSize = obj.fontSize;
        } else if (obj.element_type === 'sticky') {
            const textObj = obj._objects.find(o => o.type === 'textbox');
            if (textObj) {
                elementData.content = textObj.text;
            }
            const rectObj = obj._objects.find(o => o.type === 'rect');
            if (rectObj) {
                elementData.properties.fill = rectObj.fill;
            }
        } else if (obj.element_type === 'shape') {
            elementData.properties.fill = obj.fill;
            elementData.properties.stroke = obj.stroke;
            elementData.properties.type = obj.type === 'circle' ? 'circle' : 
                                        obj.type === 'triangle' ? 'triangle' : 'rectangle';
        } else if (obj.element_type === 'line') {
            elementData.properties.stroke = obj.stroke;
            elementData.properties.strokeWidth = obj.strokeWidth;
        } else if (obj.element_type === 'path') {
            elementData.properties.stroke = obj.stroke;
            elementData.properties.strokeWidth = obj.strokeWidth;
            elementData.path = obj.path;
        }

        // Wysłanie do API
        fetch(`/api/${boardId}/elements/${obj.id}/`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(elementData)
        })
        .then(() => {
            // Wysłanie do WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'update_element',
                    element: elementData
                }));
            }
        })
        .catch(error => console.error('Błąd aktualizacji elementu:', error));
    }

    // Wysyłanie informacji o usunięciu elementu
    function sendElementDelete(objId) {
        // Wysłanie do API
        fetch(`/api/${boardId}/elements/${objId}/`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(() => {
            // Wysłanie do WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'delete_element',
                    element_id: objId
                }));
            }
        })
        .catch(error => console.error('Błąd usunięcia elementu:', error));
    }

    // Pobranie wartości ciasteczka CSRF
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Pokazywanie panelu właściwości elementu
    function showPropertiesPanel(obj) {
        if (!obj) return;

        const panel = document.getElementById('properties-panel');
        const textProps = document.getElementById('text-props');
        const shapeProps = document.getElementById('shape-props');

        // Wspólne właściwości
        document.getElementById('element-z-index').value = obj.zIndex || 0;

        // Ukrycie wszystkich paneli specyficznych
        textProps.style.display = 'none';
        shapeProps.style.display = 'none';

        // Pokazanie odpowiedniego panelu
        if (obj.element_type === 'text') {
            textProps.style.display = 'block';
            document.getElementById('text-content').value = obj.text || '';
            document.getElementById('text-color').value = obj.fill || '#000000';
            document.getElementById('text-size').value = obj.fontSize || '16px';
        } else if (obj.element_type === 'shape') {
            shapeProps.style.display = 'block';
            document.getElementById('shape-color').value = obj.fill || '#3498db';
            document.getElementById('shape-border-color').value = obj.stroke || '#2980b9';

            const shapeTypeSelect = document.getElementById('shape-type');
            if (obj.type === 'circle') {
                shapeTypeSelect.value = 'circle';
            } else if (obj.type === 'triangle') {
                shapeTypeSelect.value = 'triangle';
            } else {
                shapeTypeSelect.value = 'rectangle';
            }
        }

        panel.style.display = 'block';
    }

    // Ukrywanie panelu właściwości
    function hidePropertiesPanel() {
        document.getElementById('properties-panel').style.display = 'none';
    }

    // Obsługa kliknięcia na płótnie dla tworzenia elementów
    function createElementHandler(opt) {
        if (opt.target || canvas.isDragging) return;

        const pointer = canvas.getPointer(opt.e);

        switch(currentTool) {
            case 'text':
                addTextElement({
                    position_x: pointer.x,
                    position_y: pointer.y
                });
                break;
            case 'sticky':
                addStickyNote({
                    position_x: pointer.x,
                    position_y: pointer.y
                });
                break;
            case 'image':
                // Tutaj możemy dodać wybór pliku
                // W uproszczonej wersji dodajemy placeholder
                addImageElement({
                    position_x: pointer.x,
                    position_y: pointer.y
                });
                break;
        }

        // Wracamy do narzędzia zaznaczania po utworzeniu elementu
        if (['text', 'sticky', 'image'].includes(currentTool)) {
            const selectButton = document.querySelector('[data-tool="select"]');
            if (selectButton) {
                selectButton.click();
            }
        }
    }

    // Konfiguracja przycisków narzędzi i obsługi zdarzeń właściwości
    function setupToolsAndProperties() {
        // Obsługa przycisków narzędzi
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                currentTool = this.dataset.tool;

                // Usunięcie aktywnej klasy z wszystkich przycisków
                document.querySelectorAll('.tool-btn').forEach(b => 
                    b.classList.remove('active', 'btn-primary', 'active-tool')
                );

                // Dodanie aktywnej klasy do klikniętego przycisku
                this.classList.add('active', 'btn-primary', 'active-tool');

                // Włączenie/wyłączenie trybu rysowania
                canvas.isDrawingMode = currentTool === 'pen';
                if (canvas.isDrawingMode) {
                    configureFreeDrawing();
                    // Pokaż właściwości pióra
                    document.getElementById('pen-properties').style.display = 'block';
                } else {
                    // Ukryj właściwości pióra
                    document.getElementById('pen-properties').style.display = 'none';
                }

                // Jeśli wybrano narzędzie do tworzenia elementów, dodajemy nasłuchiwanie kliknięcia na płótnie
                if (['text', 'sticky', 'image'].includes(currentTool)) {
                    canvas.on('mouse:down', createElementHandler);
                } else {
                    canvas.off('mouse:down', createElementHandler);
                }
            });
        });

        // Obsługa zmian właściwości elementu
        document.getElementById('element-z-index')?.addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('zIndex', parseInt(this.value));
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('text-content')?.addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'text') {
                obj.set('text', this.value);
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('text-color')?.addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'text') {
                obj.set('fill', this.value);
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('text-size')?.addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'text') {
                obj.set('fontSize', this.value);
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('shape-color')?.addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'shape') {
                obj.set('fill', this.value);
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('shape-border-color')?.addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'shape') {
                obj.set('stroke', this.value);
                sendElementUpdate(obj);
                canvas.renderAll();
            }
        });

        document.getElementById('shape-type')?.addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.element_type === 'shape') {
                const props = {
                    position_x: obj.left,
                    position_y: obj.top,
                    width: obj.width,
                    height: obj.height,
                    properties: {
                        type: this.value,
                        fill: obj.fill,
                        stroke: obj.stroke
                    }
                };

                const objId = obj.id;
                canvas.remove(obj);

                if (objId) {
                    sendElementDelete(objId);
                }

                addShapeElement(props);
            }
        });

        document.getElementById('delete-element')?.addEventListener('click', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                const objId = obj.id;
                canvas.remove(obj);

                if (objId) {
                    sendElementDelete(objId);
                }

                hidePropertiesPanel();
            }
        });

        // Obsługa ustawień pióra
        document.querySelectorAll('.brush-size-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                penSize = parseInt(this.dataset.size);

                // Aktualizacja aktywnej klasy
                document.querySelectorAll('.brush-size-btn').forEach(b => 
                    b.classList.remove('active')
                );
                this.classList.add('active');

                // Aktualizacja pędzla
                if (canvas.isDrawingMode) {
                    canvas.freeDrawingBrush.width = penSize;
                }
            });
        });

        document.getElementById('pen-color')?.addEventListener('input', function() {
            penColor = this.value;
            if (canvas.isDrawingMode) {
                canvas.freeDrawingBrush.color = penColor;
            }
        });

        document.getElementById('pen-smoothing')?.addEventListener('change', function() {
            penSmoothing = this.checked;
            if (canvas.isDrawingMode) {
                configureFreeDrawing();
            }
        });

        // Obsługa ustawień siatki
        document.getElementById('show-grid')?.addEventListener('change', function() {
            showGrid = this.checked;
            createGrid();
        });

        document.getElementById('grid-size')?.addEventListener('change', function() {
            gridSize = parseInt(this.value);
            createGrid();
        });
    }

    // Inicjalizacja po załadowaniu DOM
    document.addEventListener('DOMContentLoaded', function() {
        // Obsługa testów WebSocket
        const wsTestBtn = document.getElementById('ws-test-btn');
        if (wsTestBtn) {
            wsTestBtn.addEventListener('click', function() {
                testWebSocket(boardId);
            });
        }

        if (canEdit) {
            // Inicjalizacja WebSocket
            initializeWebSocket();

            // Konfiguracja narzędzi i właściwości
            setupToolsAndProperties();
        }

        // Inicjalizacja Canvas (dla wszystkich)
        initCanvas();

        // Ustawienie domyślnego narzędzia
        const defaultToolBtn = document.querySelector('[data-tool="select"]');
        if (defaultToolBtn) {
            defaultToolBtn.click();
        }
    });
</script>
{% endblock %}